# 工厂模式三连发之简单工厂模式

### 前言：

本篇文章电子版和配套代码下载地址:https://github.com/hanshuaikang/design-pattern-java

工厂模式也算是日常开发中应用比较多的设计模式，在Spring IOC 提供了BeanFactory，算是工厂模式的一种实现，当然看标题就可以知道，工厂模式针对不同的应用场景衍生出来很多个版本，目前应用的最广的是 简单工厂模式 ,抽象工厂模式,工厂方法模式这三种，由于按照我们一贯的风格，一次性将这三种写完会导致这篇文章将会很长，我不管，笔记本自带的键盘太硬了，我太懒了，我不想一次性写完了（气鼓鼓），除非你点关注，写个评论，立马发！哼

### 简单工厂模式定义：

工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

### 优/缺点:

**优点:**

1. 一个调用者想创建一个对象，只要知道其名称就可以了。 
2. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
3. 屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点:**

1. 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

### 应用场景：

- spring IOC实现
- 等
- 等
- 等

### 微剧场：

阿呆最近想买车，对，你没听错，这次不是什么艾玛电动车，凤凰自行车，而是想买一辆跑车（??捂嘴笑，天哪，谁给我的勇气写这个，看来我是膨胀了）。

当然，既然是阿呆买跑车，那么阿呆肯定不能自己造一辆出来，当然现在有太多中间商赚差价了，阿呆总不能自己先去4S店上班然后自己买车再辞职吧，好主意，阿呆穿上鞋就去4S店报道。

4S店老板一眼看出了阿呆的意图，阿呆被赶了出来。但没有什么能拦得住阿呆的，于是阿呆拖熟人是不是可以直接去工厂上班。

结果当然是可以的啊，不去工厂上班怎么扯掉今天要讲到工厂模式。我是作者，我说了算。

于是阿呆把自己想要车的型号告诉工厂，工厂呢根据阿呆所提供的型号交付了车辆，阿呆开着保时捷911驰骋在旧金山宽阔的道路上，笑着笑着口水就流到了床上。

看到这里大概就知道工厂模式所关注的职责了，简单工厂模式和我们的单例模式其实有着异曲同工之妙，即我们获取对象的时候只管要就行了，完全不care任何关于这个对象是怎么被造出来的，他们两个之间的区别在于简单工厂模式可以提供多个对象，根据客户的需求动态的生成满足客户条件的对象。同时，和我们之前系列文章不止一次的强调的那样，如果把对象的数量提升到一个很高的量级，即我们简单工厂模式需要维护成千上万的对象，那么我们程序肯定会爆炸的。

少废话，看代码，由于简单工厂模式实在是太过于简单，之所以花这么多的篇幅去介绍一个如此简单的设计，一是我闲得慌，二是很多东西虽然简单但是却在某些场景上要比复杂的设计模式提供更高的效率，所谓大智若愚，大繁至简。第三则是为了我们后面两个工厂模式做做一个尽可能详细的铺垫。



### 代码实战:

1. 定义一个汽车接口

```java
public interface Car {
	
	public void description();

}

```

2. 编写相关实现

```java
public class BugattiCar implements Car {

	@Override
	public void description() {
		System.out.println("布加迪跑车");
		
	}

}


public class PorscheCar implements Car  {

	@Override
	public void description() {
		System.out.println("保时捷跑车");
		
	}

}

```



编写相关工厂实现

```java
public class CarFactory {
	
	public Car getCar(String name){
		if("Porsche".endsWith(name)){
			return new PorscheCar();
		}
		else if("Bugatti".endsWith(name)){
			return new BugattiCar();
		}
		return new PorscheCar();
	
	}
	
}
```

### 测试:

```java

public class Test {
	
	public static void main(String[] args) {
		CarFactory factory = new CarFactory();
		Car car = factory.getCar("Porsche");
		car.description();
	}

}

```

### 输出:

```java
保时捷汽车
```



### 总结:

看过代码之后大概大家已经可以理解了，如果一旦工厂要管理的类过多，就会导致If else很多，这样写绝对是显得很沙雕的，为了解决这个问题，所以有了工厂方法模式和抽象工厂模式，同样的，因为简单工厂模式实在是太简单了，所以一般是不把它看作是设计模式的，更多的看作是一种代码思维。同样的，本篇文章已经同步首发至相关博客以及Github，我是韩数，我们下篇文章再见。

太困了，不行了，点个关注吧，高产似那啥。









